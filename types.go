package templ

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"html"
	"io"
	"net/http"
	"strings"

	"github.com/a-h/lexical/parse"
)

// Classes for CSS.
func Classes(classes ...CSSClass) CSSClasses {
	return CSSClasses(classes)
}

// CSSClasses is a slice of CSS classes.
type CSSClasses []CSSClass

// String returns the names of all CSS classes.
func (classes CSSClasses) String() string {
	var sb strings.Builder
	for i := 0; i < len(classes); i++ {
		c := classes[i]
		sb.WriteString(c.ClassName())
		if i < len(classes)-1 {
			sb.WriteRune(' ')
		}
	}
	return sb.String()
}

// Class returns a static CSS class name.
func Class(name string) CSSClass {
	return ConstantCSSClass(name)
}

// CSSClass provides a class name.
type CSSClass interface {
	ClassName() string
}

// ConstantCSSClass is a string constant of a CSS class name.
type ConstantCSSClass string

// ClassName of the CSS class.
func (css ConstantCSSClass) ClassName() string {
	return string(css)
}

// ComponentCSSClass is a templ.CSS
type ComponentCSSClass struct {
	// ID of the class, will be autogenerated.
	ID string
	// Definition of the CSS.
	Class SafeCSS
}

// ClassName of the CSS class.
func (css ComponentCSSClass) ClassName() string {
	return css.ID
}

// CSSID calculates an ID.
func CSSID(name string, css string) string {
	h := sha256.New()
	h.Write([]byte(css))
	hp := hex.EncodeToString(h.Sum(nil))[0:4]
	return fmt.Sprintf("%s_%s", name, hp)
}

type contextKey string

var (
	contextKeyRenderedClasses = contextKey("renderedClasses")
)

// StringSet is a set of strings.
type StringSet struct {
	ss map[string]struct{}
}

// Add string s to the set.
func (rc *StringSet) Add(s string) {
	rc.ss[s] = struct{}{}
}

// Contains returns true if s is within the set.
func (rc *StringSet) Contains(s string) bool {
	_, ok := rc.ss[s]
	return ok
}

// RenderedCSSClassesFromContext returns a set of the CSS classes that have already been
// rendered to the response.
func RenderedCSSClassesFromContext(ctx context.Context) (context.Context, *StringSet) {
	if classes, ok := ctx.Value(contextKeyRenderedClasses).(*StringSet); ok {
		return ctx, classes
	}
	rc := &StringSet{ss: make(map[string]struct{})}
	ctx = context.WithValue(ctx, contextKeyRenderedClasses, rc)
	return ctx, rc
}

func NewCSSHandler(classes ...CSSClass) CSSHandler {
	return CSSHandler{
		classes: classes,
	}
}

type CSSHandler struct {
	classes []CSSClass
}

func (cssh CSSHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/css")
	for _, c := range cssh.classes {
		if ccc, ok := c.(ComponentCSSClass); ok {
			w.Write([]byte(ccc.Class))
		}
	}
}

// Render CSS renders a <style> element with CSS content, if the styles have not already been rendered.
func RenderCSS(ctx context.Context, w io.Writer, classes []CSSClass) (err error) {
	//TODO: Add a HTTP handler that can render CSS.
	//TODO: Be able to programmatically skip rendering CSS in this way, because it's handed off to a global stylesheet.
	ctx, rc := RenderedCSSClassesFromContext(ctx)
	var sb strings.Builder
	for _, c := range classes {
		if ccc, ok := c.(ComponentCSSClass); ok {
			if !rc.Contains(ccc.ClassName()) {
				sb.WriteString(string(ccc.Class))
				rc.Add(ccc.ClassName())
			}
		}
	}
	if sb.Len() > 0 {
		if _, err = io.WriteString(w, `<style type="text/css">`); err != nil {
			return err
		}
		if _, err = io.WriteString(w, sb.String()); err != nil {
			return err
		}
		if _, err = io.WriteString(w, `</style>`); err != nil {
			return err
		}
	}
	return nil
}

// SafeCSS is CSS that has been sanitized.
type SafeCSS string

// SanitizeCSS sanitizes CSS properties to ensure that they are safe.
func SanitizeCSS(property, value string) string {
	//TODO: Something to actually sanitize the CSS.
	return property + ":" + value + ";"
}

// Component is the interface that all templates implement.
type Component interface {
	// Render the template.
	Render(ctx context.Context, w io.Writer) error
}

// ComponentFunc converts a function that matches the Component interface's
// Render method into a Component.
type ComponentFunc func(ctx context.Context, w io.Writer) error

// Render the template.
func (cf ComponentFunc) Render(ctx context.Context, w io.Writer) error {
	return cf(ctx, w)
}

// EscapeString escapes HTML text within templates.
func EscapeString(s string) string {
	return html.EscapeString(s)
}

// {% package templ %}
//
// {% import "strings" %}
// {% import strs "strings" %}
//
// {% css AddressLineStyle() %}
//   background-color: #ff0000;
//   color: #ffffff;
// {% endcss %}
//
// {% templ RenderAddress(addr Address) %}
// 	<div style={%= AddressLineStyle() %}>{%= addr.Address1 %}</div>
// 	<div>{%= addr.Address2 %}</div>
// 	<div>{%= addr.Address3 %}</div>
// 	<div>{%= addr.Address4 %}</div>
// {% endtempl %}
//
// {% templ Render(p Person) %}
//    <div>
//      <div>{%= p.Name() %}</div>
//      <a href={%= p.URL %}>{%= strings.ToUpper(p.Name()) %}</a>
//      <div>
//          {% if p.Type == "test" %}
//             <span>{%= "Test user" %}</span>
//          {% else %}
// 	    <span>{%= "Not test user" %}</span>
//          {% endif %}
//          {% for _, v := range p.Addresses %}
//             {% call RenderAddress(v) %}
//          {% endfor %}
//      </div>
//    </div>
// {% endtempl %}

// Source mapping to map from the source code of the template to the
// in-memory representation.
type Position struct {
	Index int64
	Line  int
	Col   int
}

func (p Position) String() string {
	return fmt.Sprintf("line %d, col %d (index %d)", p.Line, p.Col, p.Index)
}

// NewPosition initialises a position.
func NewPosition() Position {
	return Position{
		Index: 0,
		Line:  1,
		Col:   0,
	}
}

// NewPositionFromValues initialises a position.
func NewPositionFromValues(index int64, line, col int) Position {
	return Position{
		Index: index,
		Line:  line,
		Col:   col,
	}
}

// NewPositionFromInput creates a position from a parse input.
func NewPositionFromInput(pi parse.Input) Position {
	l, c := pi.Position()
	return Position{
		Index: pi.Index(),
		Line:  l,
		Col:   c,
	}
}

// NewExpression creates a Go expression.
func NewExpression(value string, from, to Position) Expression {
	return Expression{
		Value: value,
		Range: Range{
			From: from,
			To:   to,
		},
	}
}

// NewRange creates a range.
func NewRange(from, to Position) Range {
	return Range{
		From: from,
		To:   to,
	}
}

// Range of text within a file.
type Range struct {
	From Position
	To   Position
}

// Expression containing Go code.
type Expression struct {
	Value string
	Range Range
}

type TemplateFile struct {
	Package Package
	Imports []Import
	Nodes   []TemplateFileNode
}

func (tf TemplateFile) Write(w io.Writer) error {
	var indent int
	if err := tf.Package.Write(w, indent); err != nil {
		return err
	}
	if _, err := w.Write([]byte("\n\n")); err != nil {
		return err
	}
	if len(tf.Imports) > 0 {
		for i := 0; i < len(tf.Imports); i++ {
			if err := tf.Imports[i].Write(w, indent); err != nil {
				return err
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				return err
			}
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}
	for i := 0; i < len(tf.Nodes); i++ {
		if err := tf.Nodes[i].Write(w, indent); err != nil {
			return err
		}
		if _, err := w.Write([]byte("\n\n")); err != nil {
			return err
		}
	}
	return nil
}

// TemplateFileNode can be a Template or a CSS.
type TemplateFileNode interface {
	IsTemplateFileNode() bool
	Write(w io.Writer, indent int) error
}

// {% package templ %}
type Package struct {
	Expression Expression
}

func (p Package) Write(w io.Writer, indent int) error {
	return writeIndent(w, indent, "{% package "+p.Expression.Value+" %}")
}

func writeIndent(w io.Writer, level int, s string) (err error) {
	if _, err = w.Write([]byte(strings.Repeat("\t", level))); err != nil {
		return
	}
	_, err = w.Write([]byte(s))
	return
}

// Whitespace.
type Whitespace struct {
	Value string
}

func (ws Whitespace) IsNode() bool { return true }
func (ws Whitespace) Write(w io.Writer, indent int) error {
	// Explicit whitespace nodes are removed from templates because they're auto-formatted.
	return nil
}

// {% import "strings" %}
// {% import strs "strings" %}
type Import struct {
	Expression Expression
}

func (imp Import) Write(w io.Writer, indent int) error {
	return writeIndent(w, indent, "{% import "+imp.Expression.Value+" %}")
}

// CSS definition.
// {% css Name() %}
//   color: #ffffff;
//   background-color: {%= constants.BackgroundColor %};
//   background-image: url('./somewhere.png');
// {% endcss %}
type CSSExpression struct {
	Name       Expression
	Properties []CSSProperty
}

func (css CSSExpression) IsTemplateFileNode() bool { return true }
func (css CSSExpression) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "{% css "+css.Name.Value+"() %}\n"); err != nil {
		return err
	}
	for _, p := range css.Properties {
		if err := p.Write(w, indent+1); err != nil {
			return err
		}
	}
	if err := writeIndent(w, indent, "{% endcss %}"); err != nil {
		return err
	}
	return nil
}

// CSSProperty is a CSS property and value pair.
type CSSProperty interface {
	IsCSSProperty() bool
	Write(w io.Writer, indent int) error
}

// color: #ffffff;
type ConstantCSSProperty struct {
	Name  string
	Value string
}

func (c ConstantCSSProperty) IsCSSProperty() bool { return true }
func (c ConstantCSSProperty) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, c.Name+": "+c.Value+";\n"); err != nil {
		return err
	}
	return nil
}

// background-color: {%= constants.BackgroundColor %};
type ExpressionCSSProperty struct {
	Name  string
	Value StringExpression
}

func (c ExpressionCSSProperty) IsCSSProperty() bool { return true }
func (c ExpressionCSSProperty) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, c.Name+": "); err != nil {
		return err
	}
	if err := c.Value.Write(w, 0); err != nil {
		return err
	}
	if _, err := w.Write([]byte(";\n")); err != nil {
		return err
	}
	return nil
}

// Template definition.
// {% templ Name(p Parameter) %}
//   {% if ... %}
//   <Element></Element>
// {% endtempl %}
type Template struct {
	Name       Expression
	Parameters Expression
	Children   []Node
}

func (t Template) IsTemplateFileNode() bool { return true }

func (t Template) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "{% templ "+t.Name.Value+"("+t.Parameters.Value+") %}\n"); err != nil {
		return err
	}
	if err := writeNodesBlock(w, indent+1, t.Children); err != nil {
		return err
	}
	if err := writeIndent(w, indent, "{% endtempl %}"); err != nil {
		return err
	}
	return nil
}

// A Node appears within a template, e.g. an StringExpression, Element, IfExpression etc.
type Node interface {
	IsNode() bool
	// Write out the string.
	Write(w io.Writer, indent int) error
}

// <a .../> or <div ...>...</div>
type Element struct {
	Name       string
	Attributes []Attribute
	Children   []Node
}

var voidElements = map[string]struct{}{
	"area": {}, "base": {}, "br": {}, "col": {}, "command": {}, "embed": {}, "hr": {}, "img": {}, "input": {}, "keygen": {}, "link": {}, "meta": {}, "param": {}, "source": {}, "track": {}, "wbr": {}}

// https://www.w3.org/TR/2011/WD-html-markup-20110113/syntax.html#void-element
func (e Element) IsVoidElement() bool {
	_, ok := voidElements[e.Name]
	return ok
}

var blockElements = map[string]struct{}{
	"address": {}, "article": {}, "aside": {}, "body": {}, "blockquote": {}, "canvas": {}, "dd": {}, "div": {}, "dl": {}, "dt": {}, "fieldset": {}, "figcaption": {}, "figure": {}, "footer": {}, "form": {}, "h1": {}, "h2": {}, "h3": {}, "h4": {}, "h5": {}, "h6": {}, "head": {}, "header": {}, "hr": {}, "html": {}, "li": {}, "main": {}, "nav": {}, "noscript": {}, "ol": {}, "p": {}, "pre": {}, "script": {}, "section": {}, "table": {}, "template": {}, "tfoot": {}, "turbo-stream": {}, "ul": {}, "video": {},
}

func (e Element) isBlockElement() bool {
	_, ok := blockElements[e.Name]
	return ok
}

func (e Element) hasNonWhitespaceChildren() bool {
	for _, c := range e.Children {
		if _, isWhitespace := c.(Whitespace); !isWhitespace {
			return true
		}
	}
	return false
}

func (e Element) containsBlockElement() bool {
	for _, c := range e.Children {
		switch n := c.(type) {
		case Whitespace:
			continue
		case Element:
			if n.isBlockElement() {
				return true
			}
			continue
		case StringExpression:
			continue
		}
		// Any template elements should be considered block.
		return true
	}
	return false
}

func (e Element) IsNode() bool { return true }
func (e Element) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "<"+e.Name); err != nil {
		return err
	}
	for i := 0; i < len(e.Attributes); i++ {
		if _, err := w.Write([]byte(" ")); err != nil {
			return err
		}
		a := e.Attributes[i]
		if _, err := w.Write([]byte(a.String())); err != nil {
			return err
		}
	}
	if e.hasNonWhitespaceChildren() {
		if e.containsBlockElement() {
			if _, err := w.Write([]byte(">\n")); err != nil {
				return err
			}
			if err := writeNodesBlock(w, indent+1, e.Children); err != nil {
				return err
			}
			if err := writeIndent(w, indent, "</"+e.Name+">"); err != nil {
				return err
			}
			return nil
		}
		if _, err := w.Write([]byte(">")); err != nil {
			return err
		}
		if err := writeNodesInline(w, e.Children); err != nil {
			return err
		}
		if _, err := w.Write([]byte("</" + e.Name + ">")); err != nil {
			return err
		}
		return nil
	}
	if e.IsVoidElement() {
		if _, err := w.Write([]byte("/>")); err != nil {
			return err
		}
		return nil
	}
	if _, err := w.Write([]byte("></" + e.Name + ">")); err != nil {
		return err
	}
	return nil
}

func writeNodesInline(w io.Writer, nodes []Node) error {
	return writeNodes(w, 0, nodes, false)
}

func writeNodesBlock(w io.Writer, indent int, nodes []Node) error {
	return writeNodes(w, indent, nodes, true)
}

func writeNodes(w io.Writer, indent int, nodes []Node, block bool) error {
	for i := 0; i < len(nodes); i++ {
		if _, isWhitespace := nodes[i].(Whitespace); isWhitespace {
			continue
		}
		if err := nodes[i].Write(w, indent); err != nil {
			return err
		}
		if block {
			if _, err := w.Write([]byte("\n")); err != nil {
				return err
			}
		}
	}
	return nil
}

type Attribute interface {
	IsAttribute() bool
	String() string
}

// href=""
type ConstantAttribute struct {
	Name  string
	Value string
}

func (ca ConstantAttribute) IsAttribute() bool { return true }
func (ca ConstantAttribute) String() string {
	return ca.Name + `="` + html.EscapeString(ca.Value) + `"`
}

// href={%= ... }
type ExpressionAttribute struct {
	Name       string
	Expression Expression
}

func (ea ExpressionAttribute) IsAttribute() bool { return true }
func (ea ExpressionAttribute) String() string {
	return ea.Name + `={%= ` + ea.Expression.Value + ` %}`
}

// FailedSanitizationURL is returned if a URL fails sanitization checks.
const FailedSanitizationURL = SafeURL("about:invalid#TemplFailedSanitizationURL")

// URL sanitizes the input string s and returns a SafeURL.
func URL(s string) SafeURL {
	if i := strings.IndexRune(s, ':'); i >= 0 && !strings.ContainsRune(s[:i], '/') {
		protocol := s[:i]
		if !strings.EqualFold(protocol, "http") && !strings.EqualFold(protocol, "https") && !strings.EqualFold(protocol, "mailto") {
			return FailedSanitizationURL
		}
	}
	return SafeURL(s)
}

// SafeURL is a URL that has been sanitized.
type SafeURL string

// Nodes.

// CallTemplateExpression can be used to create and render a template using data.
// {%! Other(p.First, p.Last) %}
// or it can be used to render a template parameter.
// {%! v %}
type CallTemplateExpression struct {
	// Expression returns a template to execute.
	Expression Expression
}

func (cte CallTemplateExpression) IsNode() bool { return true }
func (cte CallTemplateExpression) Write(w io.Writer, indent int) error {
	return writeIndent(w, indent, `{%! `+cte.Expression.Value+` %}`)
}

// {% if p.Type == "test" && p.thing %}
// {% endif %}
type IfExpression struct {
	Expression Expression
	Then       []Node
	Else       []Node
}

func (n IfExpression) IsNode() bool { return true }
func (n IfExpression) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "{% if "+n.Expression.Value+" %}\n"); err != nil {
		return err
	}
	indent++
	if err := writeNodesBlock(w, indent, n.Then); err != nil {
		return err
	}
	indent--
	if len(n.Else) > 0 {
		if err := writeIndent(w, indent, "{% else %}\n"); err != nil {
			return err
		}
		if err := writeNodesBlock(w, indent+1, n.Else); err != nil {
			return err
		}
	}
	if err := writeIndent(w, indent, "{% endif %}"); err != nil {
		return err
	}
	return nil
}

// {% switch p.Type %}
//  {% case "Something" %}
//  {% endcase %}
// {% endswitch %}
type SwitchExpression struct {
	Expression Expression
	Cases      []CaseExpression
	Default    []Node
}

func (se SwitchExpression) IsNode() bool { return true }
func (se SwitchExpression) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "{% switch "+se.Expression.Value+" %}\n"); err != nil {
		return err
	}
	indent++
	for i := 0; i < len(se.Cases); i++ {
		c := se.Cases[i]
		if err := writeIndent(w, indent, "{% case "+c.Expression.Value+" %}\n"); err != nil {
			return err
		}
		if err := writeNodesBlock(w, indent+1, c.Children); err != nil {
			return err
		}
		if err := writeIndent(w, indent, "{% endcase %}\n"); err != nil {
			return err
		}
	}
	if len(se.Default) > 0 {
		if err := writeIndent(w, indent, "{% default %}\n"); err != nil {
			return err
		}
		if err := writeNodesBlock(w, indent+1, se.Default); err != nil {
			return err
		}
		if err := writeIndent(w, indent, "{% enddefault %}\n"); err != nil {
			return err
		}
	}
	indent--
	if err := writeIndent(w, indent, "{% endswitch %}"); err != nil {
		return err
	}
	return nil
}

// {% case "Something" %}
// ...
// {% endcase %}
type CaseExpression struct {
	Expression Expression
	Children   []Node
}

// {% for i, v := range p.Addresses %}
//   {% call Address(v) %}
// {% endfor %}
type ForExpression struct {
	Expression Expression
	Children   []Node
}

func (fe ForExpression) IsNode() bool { return true }
func (fe ForExpression) Write(w io.Writer, indent int) error {
	if err := writeIndent(w, indent, "{% for "+fe.Expression.Value+" %}\n"); err != nil {
		return err
	}
	if err := writeNodesBlock(w, indent+1, fe.Children); err != nil {
		return err
	}
	if err := writeIndent(w, indent, "{% endfor %}"); err != nil {
		return err
	}
	return nil
}

// StringExpression is used within HTML elements, and for style values.
// {%= ... %}
type StringExpression struct {
	Expression Expression
}

func (se StringExpression) IsNode() bool                  { return true }
func (se StringExpression) IsStyleDeclarationValue() bool { return true }
func (se StringExpression) Write(w io.Writer, indent int) error {
	return writeIndent(w, indent, `{%= `+se.Expression.Value+` %}`)
}
