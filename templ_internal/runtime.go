package templ_internal

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"regexp"
	"sort"
	"strings"
	"sync"

	"github.com/a-h/templ/safehtml"
)

type Component interface {
	Render(ctx context.Context, w io.Writer) error
}

func InitializeContext(ctx context.Context) context.Context {
	if _, ok := ctx.Value(contextKey).(*ContextValue); ok {
		return ctx
	}
	v := &ContextValue{}
	ctx = context.WithValue(ctx, contextKey, v)
	return ctx
}

func GetContext(ctx context.Context) (context.Context, *ContextValue) {
	v, ok := ctx.Value(contextKey).(*ContextValue)
	if !ok {
		ctx = InitializeContext(ctx)
		v = ctx.Value(contextKey).(*ContextValue)
	}
	return ctx, v
}

func WithChildren(ctx context.Context, children Component) context.Context {
	ctx, v := GetContext(ctx)
	v.children = &children
	return ctx
}

type contextKeyType int

const contextKey = contextKeyType(0)

type ContextValue struct {
	ss       map[string]struct{}
	children *Component
}

func (v *ContextValue) AddScript(s string) {
	if v.ss == nil {
		v.ss = map[string]struct{}{}
	}
	v.ss["script_"+s] = struct{}{}
}

func (v *ContextValue) HasScriptBeenRendered(s string) (ok bool) {
	if v.ss == nil {
		v.ss = map[string]struct{}{}
	}
	_, ok = v.ss["script_"+s]
	return
}

func (v *ContextValue) AddClass(s string) {
	if v.ss == nil {
		v.ss = map[string]struct{}{}
	}
	v.ss["class_"+s] = struct{}{}
}

func (v *ContextValue) HasClassBeenRendered(s string) (ok bool) {
	if v.ss == nil {
		v.ss = map[string]struct{}{}
	}
	_, ok = v.ss["class_"+s]
	return
}

// SafeScript encodes unknown parameters for safety.
func SafeScript(functionName string, params ...interface{}) string {
	encodedParams := make([]string, len(params))
	for i := 0; i < len(encodedParams); i++ {
		enc, _ := json.Marshal(params[i])
		encodedParams[i] = html.EscapeString(string(enc))
	}
	sb := new(strings.Builder)
	sb.WriteString(functionName)
	sb.WriteRune('(')
	sb.WriteString(strings.Join(encodedParams, ","))
	sb.WriteRune(')')
	return sb.String()
}

// SafeURL is a URL that has been sanitized.
type SafeURL string

// SafeCSS is CSS that has been sanitized.
type SafeCSS string

// SanitizeCSS sanitizes CSS properties to ensure that they are safe.
func SanitizeCSS(property, value string) SafeCSS {
	p, v := safehtml.SanitizeCSS(property, value)
	return SafeCSS(p + ":" + v + ";")
}

// RenderCSSItems renders the CSS to the writer, if the items haven't already been rendered.
func RenderCSSItems(ctx context.Context, w io.Writer, classes ...any) (err error) {
	if len(classes) == 0 {
		return nil
	}
	_, v := GetContext(ctx)
	sb := new(strings.Builder)
	renderCSSItemsToBuilder(sb, v, classes...)
	if sb.Len() > 0 {
		if _, err = io.WriteString(w, `<style type="text/css">`); err != nil {
			return err
		}
		if _, err = io.WriteString(w, sb.String()); err != nil {
			return err
		}
		if _, err = io.WriteString(w, `</style>`); err != nil {
			return err
		}
	}
	return nil
}

func renderCSSItemsToBuilder(sb *strings.Builder, v *ContextValue, classes ...any) {
	for _, c := range classes {
		switch ccc := c.(type) {
		case ComponentCSSClass:
			if !v.HasClassBeenRendered(ccc.ID) {
				sb.WriteString(string(ccc.Class))
				v.AddClass(ccc.ID)
			}
		case KeyValue[ComponentCSSClass, bool]:
			if !ccc.Value {
				continue
			}
			renderCSSItemsToBuilder(sb, v, ccc.Key)
		case KeyValue[CSSClass, bool]:
			if !ccc.Value {
				continue
			}
			renderCSSItemsToBuilder(sb, v, ccc.Key)
		case CSSClasses:
			renderCSSItemsToBuilder(sb, v, ccc...)
		case func() CSSClass:
			renderCSSItemsToBuilder(sb, v, ccc())
		}
	}
}

// CSSClass provides a class name.
type CSSClass interface {
	ClassName() string
}

// ConstantCSSClass is a string constant of a CSS class name.
type ConstantCSSClass string

// ClassName of the CSS class.
func (css ConstantCSSClass) ClassName() string {
	return string(css)
}

// ComponentCSSClass is a templ.CSS
type ComponentCSSClass struct {
	// ID of the class, will be autogenerated.
	ID string
	// Definition of the CSS.
	Class SafeCSS
}

// ClassName of the CSS class.
func (css ComponentCSSClass) ClassName() string {
	return css.ID
}

// SafeClass bypasses CSS class name validation.
func SafeClass(name string) CSSClass {
	return ConstantCSSClass(name)
}

// CSSID calculates an ID.
func CSSID(name string, css string) string {
	sum := sha256.Sum256([]byte(css))
	hp := hex.EncodeToString(sum[:])[0:4]
	return fmt.Sprintf("%s_%s", name, hp)
}

// KeyValue is a key and value pair.
type KeyValue[TKey comparable, TValue any] struct {
	Key   TKey   `json:"name"`
	Value TValue `json:"value"`
}

var safeClassName = regexp.MustCompile(`^-?[_a-zA-Z]+[-_a-zA-Z0-9]*$`)

const fallbackClassName = "--templ-css-class-safe-name"

// Class returns a sanitized CSS class name.
func Class(name string) CSSClass {
	if !safeClassName.MatchString(name) {
		return SafeClass(fallbackClassName)
	}
	return SafeClass(name)
}

// CSSClasses is a slice of CSS classes.
type CSSClasses []any

// String returns the names of all CSS classes.
func (classes CSSClasses) String() string {
	if len(classes) == 0 {
		return ""
	}
	cp := newCSSProcessor()
	for _, v := range classes {
		cp.Add(v)
	}
	return cp.String()
}

func newCSSProcessor() *cssProcessor {
	return &cssProcessor{
		classNameToEnabled: make(map[string]bool),
	}
}

type cssProcessor struct {
	classNameToEnabled map[string]bool
	orderedNames       []string
}

func (cp *cssProcessor) Add(item any) {
	switch c := item.(type) {
	case []string:
		for _, className := range c {
			cp.AddUnsanitized(className, true)
		}
	case string:
		cp.AddUnsanitized(c, true)
	case ConstantCSSClass:
		cp.AddSanitized(c.ClassName(), true)
	case ComponentCSSClass:
		cp.AddSanitized(c.ClassName(), true)
	case map[string]bool:
		// In Go, map keys are iterated in a randomized order.
		// So the keys in the map must be sorted to produce consistent output.
		keys := make([]string, len(c))
		var i int
		for key := range c {
			keys[i] = key
			i++
		}
		sort.Strings(keys)
		for _, className := range keys {
			cp.AddUnsanitized(className, c[className])
		}
	case []KeyValue[string, bool]:
		for _, kv := range c {
			cp.AddUnsanitized(kv.Key, kv.Value)
		}
	case KeyValue[string, bool]:
		cp.AddUnsanitized(c.Key, c.Value)
	case []KeyValue[CSSClass, bool]:
		for _, kv := range c {
			cp.AddSanitized(kv.Key.ClassName(), kv.Value)
		}
	case KeyValue[CSSClass, bool]:
		cp.AddSanitized(c.Key.ClassName(), c.Value)
	case CSSClasses:
		for _, item := range c {
			cp.Add(item)
		}
	case func() CSSClass:
		cp.AddSanitized(c().ClassName(), true)
	default:
		cp.AddSanitized(unknownTypeClassName, true)
	}
}

func (cp *cssProcessor) AddUnsanitized(className string, enabled bool) {
	for _, className := range strings.Split(className, " ") {
		className = strings.TrimSpace(className)
		if isSafe := safeClassName.MatchString(className); !isSafe {
			className = fallbackClassName
			enabled = true // Always display the fallback classname.
		}
		cp.AddSanitized(className, enabled)
	}
}

func (cp *cssProcessor) AddSanitized(className string, enabled bool) {
	cp.classNameToEnabled[className] = enabled
	cp.orderedNames = append(cp.orderedNames, className)
}

func (cp *cssProcessor) String() string {
	// Order the outputs according to how they were input, and remove disabled names.
	rendered := make(map[string]any, len(cp.classNameToEnabled))
	var names []string
	for _, name := range cp.orderedNames {
		if enabled := cp.classNameToEnabled[name]; !enabled {
			continue
		}
		if _, hasBeenRendered := rendered[name]; hasBeenRendered {
			continue
		}
		names = append(names, name)
		rendered[name] = struct{}{}
	}

	return strings.Join(names, " ")
}

const unknownTypeClassName = "--templ-css-class-unknown-type"

// Classes for CSS.
// Supported types are string, ConstantCSSClass, ComponentCSSClass, map[string]bool.
func Classes(classes ...any) CSSClasses {
	return CSSClasses(classes)
}

func ClearChildren(ctx context.Context) context.Context {
	_, v := GetContext(ctx)
	v.children = nil
	return ctx
}

// NopComponent is a component that doesn't render anything.
var NopComponent = ComponentFunc(func(ctx context.Context, w io.Writer) error { return nil })

// GetChildren from the context.
func GetChildren(ctx context.Context) Component {
	_, v := GetContext(ctx)
	if v.children == nil {
		return NopComponent
	}
	return *v.children
}

type ComponentFunc func(context.Context, io.Writer) error

// Render the template.
func (cf ComponentFunc) Render(ctx context.Context, w io.Writer) error {
	return cf(ctx, w)
}

// Script handling.

// ComponentScript is a templ Script template.
type ComponentScript struct {
	// Name of the script, e.g. print.
	Name string
	// Function to render.
	Function string
	// Call of the function in JavaScript syntax, including parameters.
	// e.g. print({ x: 1 })
	Call string
}

// RenderScriptItems renders a <script> element, if the script has not already been rendered.
func RenderScriptItems(ctx context.Context, w io.Writer, scripts ...ComponentScript) (err error) {
	if len(scripts) == 0 {
		return nil
	}
	_, v := GetContext(ctx)
	sb := new(strings.Builder)
	for _, s := range scripts {
		if !v.HasScriptBeenRendered(s.Name) {
			sb.WriteString(s.Function)
			v.AddScript(s.Name)
		}
	}
	if sb.Len() > 0 {
		if _, err = io.WriteString(w, `<script type="text/javascript">`); err != nil {
			return err
		}
		if _, err = io.WriteString(w, sb.String()); err != nil {
			return err
		}
		if _, err = io.WriteString(w, `</script>`); err != nil {
			return err
		}
	}
	return nil
}

var bufferPool = sync.Pool{
	New: func() any {
		return new(bytes.Buffer)
	},
}

func GetBuffer() *bytes.Buffer {
	return bufferPool.Get().(*bytes.Buffer)
}

func ReleaseBuffer(b *bytes.Buffer) {
	b.Reset()
	bufferPool.Put(b)
}
